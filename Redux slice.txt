
A **slice** is a **self-contained piece of Redux state logic**.

It bundles **state + reducers + actions** for one feature.

Example:

```js
const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 },
  reducers: {
    increment(state) { state.value++ },
    decrement(state) { state.value-- }
  },
  extraReducers: (builder) => {
    builder.addCase(fetchUsers.pending, (state) => {
      state.loading = true;
    }).addMatcher(
    (action) => action.type.endsWith('/pending'),
    (state) => {
      state.loading = true;
    }
   );
  }
});
```

This **one slice** gives you:

* **State:** `counter`
* **Actions:** `increment`, `decrement`
* **Reducer:** `counterSlice.reducer`

**Why it‚Äôs called a slice:**
It manages *one slice* of the global Redux store (e.g., `store.counter`).

**Before (Redux):** separate files for actions, reducers, constants
**Now (RTK slice):** everything in one place

üëâ **Slice = feature-level Redux logic in one object**
-----------------------------------------------------------------------
Actions is auto-generated by Redux Toolkit when you create the slice.
Redux Toolkit automatically creates action creators for each reducer and exposes them on:

export const { increment, decrement, incrementByAmount } =
  counterSlice.actions;
------------------------------------------------------------------------------------------------
createSlice returns an object, and one of its properties is reducer.
Redux Toolkit internally builds a single reducer function from those case reducers and attaches it as:

export default counterSlice.reducer;

----------------------------------------------------------------------
Actions = plain objects

{ type: 'counter/increment' }

Reducers = functions that handle actions and update state

In a slice:

reducers: {
  increment(state) { state.value++ }
}

increment is a case reducer 

Redux Toolkit uses it to:

Generate an action ‚Üí counter/increment

Generate reducer logic for that action

-----------------------------------------------------------------------
name:'counter'
It is used only for:

Action type prefixing
counter/increment

DevTools readability

----------------------------------------------------------------------
Immer lets you write mutable-looking updates while keeping state immutable (Redux Toolkit uses it by default).

You can ‚Äúmutate‚Äù state only inside reducers (because of Immer).
----------------------------------------------------------------------------
extraReducers lets a slice respond to actions it did NOT create.
When to use

Handle async thunks (createAsyncThunk)

React to actions from other slices

Handle external actions (e.g. reset, logout)
reducers = actions you own
extraReducers = actions you listen to

Used heavily with async logic and cross-slice behavior.

------------------------------------------------------------------------
builder.addMatcher() (match ending) lets you handle multiple actions that match a pattern, instead of one exact action.
addCase ‚Üí exact match
addMatcher = flexible, condition-based action matching