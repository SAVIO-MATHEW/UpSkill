Ahhh now youâ€™re thinking like a senior dev, nice ğŸ˜
Code maintainability is what separates â€œit worksâ€ from â€œit survives 2 years of changes.â€

ğŸ§  What is maintainable code

Code that is easy to read, change, debug, and extend by someone who didnâ€™t write it (including future you).

ğŸ”‘ Core Principles
1ï¸âƒ£ Readability > Cleverness

Bad

const x=a=a.map(b=b.n.length).sort((c,d)=c-d)[0]


Good

const getShortestNameLength = users =
  users.map(u = u.name.length).sort((a, b) = a - b)[0];


If someone needs 5 mins to understand it â†’ not maintainable.

2ï¸âƒ£ Single Responsibility

Each functioncomponent should do one job.

âŒ Component fetching + sorting + rendering + filtering
âœ… Separate logic

useFetch()    data logic
useSort()     sorting logic
UserList      UI

3ï¸âƒ£ Avoid Repetition (DRY)

Bad

fetchUsers()
fetchProducts()
fetchOrders()


Better

useFetch(url)

4ï¸âƒ£ Predictable State

Never mutate

data.push(x) âŒ
data.sort() âŒ


Use immutable updates

setData(prev = [...prev, x])


Predictable code = fewer bugs.

5ï¸âƒ£ Clear Naming

Bad

const d = await f();


Good

const users = await fetchUsers();


Names should explain intent, not mechanics.

6ï¸âƒ£ Small Components

âŒ 400-line component
âœ… Split

App
 â”œâ”€â”€ UserList
 â”œâ”€â”€ UserItem
 â””â”€â”€ SortButton

7ï¸âƒ£ Error Handling

Maintainable code doesnâ€™t silently fail.

if (!res.ok) throw new Error(Failed to fetch users);

8ï¸âƒ£ Consistency

Pick one style and stick to it

Arrow components or function components

Semicolons or not

Folder structure

Inconsistency = mental load.

ğŸš¨ Biggest maintainability killer

Tightly coupled code

Bad

component â†’ directly calls API â†’ transforms â†’ renders


Better

UI layer
Logic layer (hooks)
Service layer (API)

ğŸ† Senior Mindset

When writing code ask

â€œWill this be easy to change laterâ€

â€œCan another dev understand this in 30 secondsâ€

â€œIf requirements change, do I rewrite everythingâ€

If answer = no â†’ refactor.