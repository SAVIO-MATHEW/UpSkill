React.memo is a higher-order component that memoizes a functional component.
It prevents a component from re-rendering if its props have not changed.
Youâ€™re basically asking:

> â€œA function is recreated every renderâ€¦ so whatâ€™s the big deal?â€

Letâ€™s slow it down.

---

## ğŸ”¥ First truth

Yes â€” **functions are recreated every render**.

```js
function Parent() {
  const handleClick = () => console.log("Hi");
}
```

On every render â†’ **new function object in memory**.

---

## ğŸ§  Why is that a problem?

Because in JavaScript:

```js
() => {} !== () => {}
```

Even if code is identical, references are different.

React uses **reference equality** for props comparison.

---

## ğŸ¯ Where this matters

### Case without `useCallback`

```js
const Child = React.memo(({ onClick }) => {
  console.log("Child rendered");
  return <button onClick={onClick}>Click</button>;
});

function Parent() {
  const [count, setCount] = useState(0);

  const handleClick = () => console.log("Hi");

  return (
    <>
      <button onClick={() => setCount(count + 1)}>+</button>
      <Child onClick={handleClick} />
    </>
  );
}
```

Every time Parent re-renders:

* New `handleClick` function
* `onClick` prop reference changes
* `React.memo` sees props changed
* Child re-renders âŒ

Even though logic is same.

---

## âœ… With `useCallback`

```js
const handleClick = useCallback(() => {
  console.log("Hi");
}, []);
```

Now React says:

> â€œDependencies didnâ€™t change â†’ reuse the same function reference.â€

So:

```
prevOnClick === nextOnClick  â†’ true
```

Child does NOT re-render âœ…

---

## ğŸ’¡ So the difference is NOT behavior â€” it's **identity**

| Without useCallback      | With useCallback      |
| ------------------------ | --------------------- |
| New function each render | Same function reused  |
| New reference            | Stable reference      |
| Breaks React.memo        | Works with React.memo |

---

## ğŸ§  Important insight

If you are **not passing the function to a memoized child**, `useCallback` does NOTHING useful.

```js
<button onClick={handleClick} />
```

Here React doesnâ€™t compare props â†’ no benefit.

---

## ğŸ§© Simple memory trick

> `useCallback` is not for speed
> Itâ€™s for **reference stability**

---

Want to see a visual â€œrender log timelineâ€ of Parent & Child with and without `useCallback`? Thatâ€™s where it clicks forever.
