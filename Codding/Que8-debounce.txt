function debounce(func, delay) {
  let timeoutId; // ← lives in closure, shared across calls

  return function (...args) {        // ← the debounced function
    const context = this;            // ← preserve `this`

    clearTimeout(timeoutId);         // ← cancel previous

    timeoutId = setTimeout(() => {   // ← schedule new
      func.apply(context, args);     // ← call func with correct this/args
    }, delay);
  };
}

const debouncedLog = debounce((msg) => console.log(msg), 1000);

debouncedLog('First');   // t = 0ms
debouncedLog('Second');  // t = 100ms
debouncedLog('Third');   // t = 200ms
-----------------------------------------------------------

import { useState, useRef } from "react";

export default function DebounceComp() {
  const [data, setData] = useState("");
  const debounceRef = useRef(null);

  function debounce(value) {
    if (debounceRef.current) {
      clearTimeout(debounceRef.current);
    }

    debounceRef.current = setTimeout(() => {
      console.log("input", value);
    }, 1000);
  }

  return (
    <div>
      <input
        type="text"
        value={data}
        onChange={(e) => {
          setData(e.target.value);
          debounce(e.target.value);
        }}
      />
    </div>
  );
}


debounce uses closures to persist the timer, but in React we use useRef because component re-renders reset local variables.