Async thunk (Redux Toolkit) = a helper to write async logic that dispatches actions automatically.

What it does

createAsyncThunk creates 3 action types for one async task:

pending   ‚Üí started
fulfilled ‚Üí success
rejected  ‚Üí failed

export const fetchUser = createAsyncThunk(
  'user/fetch',
  async (id) => {
    const res = await fetch(`/api/users/${id}`);
    return res.json();
  }
);

Auto-generated actions:

text
user/fetch/pending
user/fetch/fulfilled
user/fetch/rejected
-------------------------------------------------------------------------

Here‚Äôs a complete, minimal, interview-ready example showing how an async thunk is defined, called, and handled inside a slice.

1Ô∏è‚É£ Async thunk
// userThunk.js
import { createAsyncThunk } from '@reduxjs/toolkit';

export const fetchUser = createAsyncThunk(
  'user/fetchUser',
  async (userId, thunkAPI) => {
    const response = await fetch(
      `https://jsonplaceholder.typicode.com/users/${userId}`
    );

    if (!response.ok) {
      return thunkAPI.rejectWithValue('Failed to fetch user');
    }

    return response.json(); // üëà THIS is the response
  }
);

'''''''''''''''''''''
That return value becomes:

action.payload

when:

fetchUser.fulfilled

is dispatched.

````````````````````````````````````````````````````````````
2Ô∏è‚É£ Slice using the async thunk
// userSlice.js
import { createSlice } from '@reduxjs/toolkit';
import { fetchUser } from './userThunk';

const initialState = {
  user: null,
  loading: false,
  error: null
};

const userSlice = createSlice({
  name: 'user',
  initialState,
  reducers: {},

  extraReducers: (builder) => {
    builder
      .addCase(fetchUser.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchUser.fulfilled, (state, action) => {
        state.loading = false;
        state.user = action.payload; // üëà response used here
      })
      .addCase(fetchUser.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload || action.error.message;
      });
  }
});

export default userSlice.reducer;

````````````````````````````````````````````````````
3Ô∏è‚É£ Store setup
// store.js
import { configureStore } from '@reduxjs/toolkit';
import userReducer from './userSlice';

export const store = configureStore({
  reducer: {
    user: userReducer
  }
});

``````````````````````````````````````````````````````````

4Ô∏è‚É£ Calling the async thunk (React component)
// UserComponent.jsx
import { useDispatch, useSelector } from 'react-redux';
import { fetchUser } from './userThunk';

export default function UserComponent() {
  const dispatch = useDispatch();
  const { user, loading, error } = useSelector((state) => state.user);

  return (
    <div>
      <button onClick={() => dispatch(fetchUser(1))}>
        Fetch User
      </button>

      {loading && <p>Loading...</p>}
      {error && <p>{error}</p>}
      {user && <p>{user.name}</p>}
    </div>
  );
}
----------------------------------------------------------------------------
‚ÄúThunk dispatches actions; reducers read payload‚Äù
The response becomes action.payload of the fulfilled action.
-----------------------------------------------------------------------------
unwrap

Lets you treat a thunk like a normal async function.
Use unwrap() when you need response in UI
unwrap() extracts action.payload
unwrap() guarantees success-only resolution; any failure causes a rejection that must be handled.
unwrap() exists to convert Redux action results into Promise semantics so UI code can handle success and failure naturally.
unwrap() is called where you dispatch the async thunk ‚Äî typically inside a component‚Äôs event handler or another async function ‚Äî to handle success/failure with normal Promise logic.
match

Safely checks which thunk lifecycle action was dispatched.
-----------------------------------------------------------------------
Async thunk returns the final dispatched action; unwrap() converts that action into a resolved or rejected promise.
A slice knows it‚Äôs pending because createAsyncThunk automatically dispatches a pending action that the slice handles in extraReducers.

----------------------------------------------------------
rejectWithValue lets async thunks return a custom error payload that reducers and unwrap() can reliably consume.