console.log(a);

var a = 10;
o/p:undefined
----------------------------------------
console.log(b);

let b = 20;
o/p:reference error
--------------------------------------
{

  var x = 1;

  let y = 2;

}

console.log(x);

console.log(y);
o/p:
1
ReferenceError: y is not defined

 -----------------------------------------
function outer() {

  let count = 0;

  return function inner() {

    count++;

    console.log(count);

  };

}
 
const fn = outer();

fn();

fn();

Hint:closure
o/p:
1
2

 -----------------------------------


function example() {

    var x = 1;

    let y = 2;

    const z = 3;
 
    if (true) {

        var x = 10; 

        let y = 20; 

        const z = 30;

        console.log(x, y, z); 

    }
 
    console.log(x, y, z); 

}
o/p:
10 20 30
10 2 3

--------------------------------------------
 
const myPromise = new Promise((resolve, reject) => {

  setTimeout(() => {

    reject('Rejected');

  }, 200)

  setTimeout(() => {

    resolve('Resolved');

  }, 300);

});

myPromise

.then(e => console.log('Success', e))

.catch(e => console.log('Failed', e))

.finally(e => console.log('Final', e))

o/p:
Failed Rejected
Final undefined

--------------------------------------------------------------
 
const { x: a = 10, y: b = 20 } = { x: undefined, y: null };

console.log(a, b);

o/p:
10 null

Hint:
Why?

Default values in destructuring apply only when the value is undefined, not null.

x: undefined
a = 10   // default used

y: null
b = null // default NOT used


Because JS treats:

	Value		Default applied?
	undefined	âœ… Yes
	null		âŒ No
	missing key	âœ… Yes

Think of it as:

Default works only if value is missing or undefined, not when itâ€™s intentionally set (even to null).
 ------------------------------------------------------
console.log('Hello ' + 5);    Hello 5   

console.log(5 + '5');            55

console.log(null + 'text');       nulltext

console.log(1 == '1');            true

console.log(null == undefined);		true
``````````````````````````````````````
1ï¸âƒ£ 'Hello ' + 5

Number â†’ string
âž¡ "Hello 5"

2ï¸âƒ£ 5 + '5'

String present â†’ concatenation
âž¡ "55"

3ï¸âƒ£ null + 'text'

null becomes "null" in string context
âž¡ "nulltext"

4ï¸âƒ£ 1 == '1'

Loose equality (==) does type conversion
'1' â†’ number
âž¡ 1 == 1 â†’ true

5ï¸âƒ£ null == undefined

Special rule in JS:

null == undefined  â†’ true
null === undefined â†’ false


Theyâ€™re only equal to each other in loose comparison.
`````````````````````````````````````````````````````````````````
Equality comparison is more â€œnumeric logicâ€ focused, while + is also a string operator.

More examples
'5' == 5        // true  (string â†’ number)
true == 1       // true  (true â†’ 1)
false == 0      // true
'' == 0         // true  ('' â†’ 0 ðŸ˜¬)

ðŸ”¹ == (loose equality) rule is DIFFERENT

When comparing number and string:

String is converted to number, not the other way around.

So:

1 == '1'


JS does:

'1' â†’ Number('1') â†’ 1
1 == 1 â†’ true

This is why devs avoid == â€” too many hidden conversions.

Rule to lock in ðŸ§ 
	Operator	String present â†’ what happens?
	  +		  everything â†’ string
	  ==		  string â†’ number

 -----------------------------------------------------------
async function test() {

  console.log('Start');

  const p1 = new Promise((resolve) => setTimeout(() => resolve('P1'), 1000));

  const p2 = new Promise((resolve) => setTimeout(() => resolve('P2'), 500));

  console.log(await p1);

  console.log(await p2);

  console.log('End');

}

test();
o/p:
Start
P1
P2
End

Hint:
Why this happens

Even though p2 finishes earlier (500ms), it doesn't matter.

Step-by-step

"Start" prints immediately.

Both promises start running in parallel.

await p1 pauses the function for 1 second.

During that time, p2 already resolves at 500msâ€¦
but the code is still waiting for p1.

After 1s â†’ P1 logs.

Now await p2 runs â€” but it's already resolved, so it prints instantly.

"End" prints.
Key rule

await is sequential, not â€œwho finishes firstâ€.

If you wanted fastest-first
const [r1, r2] = await Promise.all([p1, p2]);
`````````````````````````````````````````````````````````
async function test() {
  console.log('Start');
  const start = Date.now();

  const p1 = new Promise(r => setTimeout(() => r('P1'), 1000));
  const p2 = new Promise(r => setTimeout(() => r('P2'), 500));

  const promises = [
    p1.then(v => ({ label: 'p1', value: v, time: Date.now() - start })),
    p2.then(v => ({ label: 'p2', value: v, time: Date.now() - start }))
  ];

  promises.forEach(p =>
    p.then(res => console.log(res.label, res.value, res.time, 'ms'))
  );

  await Promise.all(promises);
  console.log('End');
}

test();

----------------------------------------------------------- 
memoisation
Caching function results based on inputs.

const memoAdd = memoize((a, b) => a + b);
memoAdd(2,3); // computed
memoAdd(2,3); // from cache


ðŸ‘‰ Works outside React, any function.
 -------------------------------------------------
import React from "react";

const APIURL = "https://jsonplaceholder.typicode.com/users";
 
function App() {

  return (
<main>
<h1>User List</h1>
<div>
<button >Get Users</button>
<button >Sort list by name's length</button>
</div>
<ul>

        //list goes here
</ul>
</main>

  );

}

export default App;
----------------------------------------------
Anagram-
function isAnagram(a, b) {
  return a.split('').sort().join('') === b.split('').sort().join('');
}
------------------------------------------------------------------
const p = new Promise((resolve, reject) => {
  setTimeout(() => resolve("Done"), 0);
  console.log("Hello");
});

p.then(console.log);
console.log("World");
o/p:Hello
World
Done
````````````````````````````````````````````````````````````````````````
Order of execution:

Sync code â†’ Microtasks (Promises) â†’ Macrotasks (setTimeout)


But here the promise only resolves inside a macrotask (setTimeout), so:

Sync â†’ Timer â†’ Promise microtask


 